%%Énoncé
Nous considérons un tableau $A$ à 2 dimensions ($n * n$ éléments) qui contient des 1 et des 0, de telle sorte que, sur chaque ligne de $A$, tous les 1 présents viennent avant tout 0 sur cette ligne.
En supposant que $A$ est déjà en mémoire, décrivez un algorithme qui compte le nombre de 1 dans $A$ et s'exécute en $O(n$ $log$ $n)$ (et non pas $\Theta(n^2)$).
Justifiez pourquoi la complexité temporelle  de votre algorithme est bien en $\Theta(n$ $log$ $n)$ \textit{(Tanguy)}

%%Réponse
\lstinputlisting[language=java, inputencoding=utf8]{pseudo-code-question3.java}

Le pseudo-code ci-dessus s'exécute en $\Theta(n\log(n))$ car à chaque itération de la boucle \textit{while}, la moitié des sous-possibilités est éliminée et qu'il faut parcourir les $n$ lignes du tableaux.